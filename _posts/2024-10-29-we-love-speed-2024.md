---
layout: post
title: We love speed 2024 ❤️
description: How did we improve the monitoring practices on the mobile service? Let's find out.
author: [ j_nginn, j_poissonnet ]
tags: [ monitoring, production, newrelic, shared practice, alerting ]
color: rgb(251,87,66)
language: fr
thumbnail: "TODO"
---

# We love speed ❤️

Cette année, nous avons eu la chance de participer à la conférence We love speed, une conférence annuelle axée sur la
performance du web.
Etant donné que c’est un domaine qui nous passionne <insérer le lien d’un article qui en parle ?>, nous sommes très
content d’avoir pu y assister.
Le thème de cette année, c’est l’INP. En effet, cette métrique de performance a été ajoutée aux core web vitals par
Google récemment https://developers.google.com/search/blog/2023/05/introducing-inp?hl=fr
L’idée de cette métrique est de se rapprocher de l’expérience de l’utilisateur envers la réactivité d’une application
web. Cette métrique observe le temps entre une interaction utilisateur et une réponse visuelle de notre interface.

## HTMX

Lors de ce talk, il nous a été présenté un outil très intéressant pour améliorer l’expérience utilisateur d’une
application web sans effectuer de grosses modifications.
Il s'agit de HTMX, c'est une bibliothèque Javascript qui permet d’améliorer l’expérience utilisateur en ajoutant des
fonctionnalités de type SPA (Single Page Application) à une application web classique et de façon non intrusive.
Par exemple, on peut charger un CDN de manière asynchrone, ou encore charger des images en avance.
C’est-a-dire que si HTMX venait à ne pas démarrer, votre application web se comporterait de la même manière, mais sans
les améliorations de temps d’interaction.
HTMX surcharge la manière dont vos liens et images vont être chargés par le navigateur.
Ainsi, lors de la prochaine interaction avec le navigateur, ce dernier sera déjà prêt à servir les ressources.
Le principe de HTMX consiste à ajouter des balises HTML spécifiques dans le DOM qu'il va lire et en déduire les
comportements à son chargement.
Cette manipulation est appelé le "DOM morphing". Grâce à ce processus le temps de chargement est réduite et on évite
l'effet "blink" (page blanche lors du chargement de la page).
Il est à noter que ces comportements ne sont qu’un embellissement proposé par HTMX, il est tout à fait possible
d’ajouter par exemple l’attribut `preload` sur une balise `a` pour demander le chargement en avance du lien par le
navigateur.

> <div style="display: flex">
> <img src="https://ca.slack-edge.com/T108ZKPMF-U01FQRQ8FT7-dfb12b21fb0d-192" style="border-radius: 50%; height: 30px; margin: 10px">
> Comme nous utilisons React pour notre application, l'utilisation de HTMX n'est pas vraiment utile.
> Il est déjà possible avec React de précharger les ressources en avance. Mais ça reste un outil intéressant.
> </div>

## INP vs JS

Le deuxième talk a une place particulière dans notre cœur ❤️ puisqu’il a été donné par notre cher Jean-Pierre Vincent,
qui a audité les performances du web de Bedrock il y a deux ans. C’était très intéressant de voir les principes que JP
s’adonne à inculquer impacté cette nouvelle mesure qu’est l’INP. Un de ces principes est d’éviter le plus possible la
déferlante de Javascript que vos utilisateurs reçoivent au chargement de votre site.
![JS Tsunami storming your users](/images/posts/2024-10-29-we-love-speed-2024/js_tsunami.jpeg)
L’idée avec l’INP est de mesurer l’incapacité du navigateur à réagir. Après avoir récupéré des mesures, il est bon de
se rappeler qu’il y a un biais de selection pour les données de Crux, en effet il n’est calculé que sur les appareils
Google (c’est le principe). Une fois qu’on a récolté des métriques de performance de nos utilisateurs, si on veut
travailler sur notre site web et avoir une bonne idée du ressenti de nos utilisateurs, l’idéal est de tester avec un
véritable Samsung S8
L’INP est une métrique qui peut être influencée par des interactions que ne sont pas prévues par les devs. C’est
pourquoi il est important de se baser sur des données utilisateurs, car on est très souvent étonné de voir que quand les
temps de chargement sont un poil trop long à leur goût ils se mettent à cliquer partout. 🤷
![INP est bousculé par la charge de js!](/images/posts/2024-10-29-we-love-speed-2024/inp_charge.jpeg)
￼

Parmi les bonnes pratiques qu’on peut appliquer dès maintenant, et qui je dois le dire m’a paru un peu contre-intuitif :
Faire passer Babel sur les node_modules.
En fait, du point de vue d’un développeur, on peut se dire que cela va augmenter les temps de build drastiquement, et on
aurait surement raison. Mais en fait il faut voir le bénéfice qu’il y a derrière. Si on personnalise les règles Babel
pour qu’elles correspondent aux navigateurs de nos utilisateurs on s’évite des transformations inutiles qui plomberaient
le poids de nos fichiers Javascript.

Une évolution du framework React permet de créer des Server Components, ce qui est très intéressant du point de vue de
la réduction du Javascript. Vous l’aurez compris, c’est l’ennemi numéro 1 de JP (et de vos navigateurs). Les React
Server Components c’est vraiment bien, l’idée est de rendre les composants côté serveur et de faire en sorte que ces
derniers ne rendent que du HTML, qui ne sera pas hydraté côté client. L’étape de réhydratation est une étape importante
et trop souvent sous-estimée. Il s’agit d’une nouveauté de React qui est prometteuse, et qui est déjà présent dans
Next.js.

Un exemple d’abus de Javascript qui a été montré pendant la présentation se trouve être du code de chez nous 😅. Il
s’agit d’un flamegraph du rendu de notre Footer. Il est conséquent parce que nous faisons ce qu’on appelle du CSS-in-JS.
Vous l’avez devinez, c’est la partie in-JS le problème. Cela signifie que pour appliquer du style sur notre site, c’est
le Javascript qui s’en charge, or dans un composant comme le Footer, il y a beaucoup d’éléments, et chaque élément va
avoir besoin de son style. Si l’idée de colocaliser le CSS dans le JS n’est pas nocive en soit, le problème que nous
avons c’est que nous utilisons Styled-Components, qui calcule le style au moment du rendu, le rendant donc plus long.
FYI: nous avons chez Bedrock entamé une migration pour quitter Styled-Components au profit de Linaria  
![Flamegraph du Footer de Bedrock](/images/posts/2024-10-29-we-love-speed-2024/flamgraph.jpeg)
￼

Autre information qui nous concerne à Bedrock, nous sommes au moment d’écrire ces lignes en train de mettre en
production la migration de React 17 vers React 18. D’après les retours d’expérience de JP, React 18 est bon pour l’INP
car il permet de faire moins de render.

Enfin, Jean-Pierre nous laisse avec un ultime conseil pour que nos applications web soient pérennes : “Monitore (au
moins une fois dans ta vie) l’origine des INP avec un vrai user.”

## Performance with devtools

Avoir un œil sur ses performances, c’est essentiel pour pouvoir avancer dans la bonne direction et s’assurer qu’on
fournit à nos utilisateurs une expérience optimale. Fort heureusement pour nous les devs, on est bien lotis avec de très
bons outils. Il suffit d’ouvrir les chrome devtools pour s’en rendre compte.

When profiling use throttling !!!! (At best use remote debugging and screen casting)
Use actual devices ffs
You can add label/diagram/time range annotations in the flamegraph
CUSTOM TRACKS TO THE MOON

- with user timing api

￼
Insight is a really nice feature of devtools
Especially layout shift insights
￼
??? Speculation Rules ???
Ai explained error message in console !
• Page prerendering
• Local overrides + header overrides
• Speculation rules debugging
• Snippets
Déjeuner
Abtasty c’était pas bien il y a un moment - Antoine de Fastly

## How I made the web faster with INP

￼
"When I get back to work, I'll have to check how my website handles event tracking calls to analytics platforms."
Custom properties cause style recalculation in the presentation step
You can disable the inheritance with JS on the CSS properties
Jake archibald - in the loop

## Web perf testing

Lighthouse CI - run lighthouse inside the CI to integrate the web performance test in the dev phase instead of after
deployment
![Key takeaways from the talk](/images/posts/2024-10-29-we-love-speed-2024/Key%20Takeaways.jpeg)
￼

## How browsers really load pages

￼
Use preload with surgical precision
![Preload with surgical precision](/images/posts/2024-10-29-we-love-speed-2024/preload_surgical.jpeg)
￼
If you're loading 5MB of JavaScript without a CDN, you have bigger problems than just tight mode messing up!
Mais que fait la police ?!
￼
On peut optimiser les fonts de fallback
￼
On peut réaliser des subsets de font pour éviter de télécharger tous les glyphes dans une font (en français on a besoin
que de 165 glyphes la ou les tables latin en exposent 528)
Ressource : Font subsetter / fontttools / glyphanger
![Say no to tofu](/images/posts/2024-10-29-we-love-speed-2024/tofu.jpeg)
￼
Pour minimiser le nombre de fichier, on peut utiliser des polices variables
Encore une fois, via un outil un peut subsetter les variations.
