---
layout: post
title: We love speed 2024 â¤ï¸
description: How did we improve the monitoring practices on the mobile service? Let's find out.
author: [ j_nginn, j_poissonnet ]
tags: [ monitoring, production, newrelic, shared practice, alerting ]
color: rgb(251,87,66)
language: fr
thumbnail: "images/posts/2024-10-29-we-love-speed-2024/welovespeed_2024-1709240237.jpg"
---

Cette annÃ©e, nous avons eu la chance de participer Ã  la confÃ©rence We love speed, une confÃ©rence annuelle axÃ©e sur la
performance du web.
Câ€™est un domaine qui nous passionne <insÃ©rer le lien dâ€™un article qui en parle ?> et nous sommes trÃ¨s
content dâ€™avoir pu y assister.
Le thÃ¨me de cette annÃ©e, câ€™est lâ€™INP. En effet, cette mÃ©trique de performance a Ã©tÃ© ajoutÃ©e aux core web vitals par
Google rÃ©cemment https://developers.google.com/search/blog/2023/05/introducing-inp?hl=fr
Lâ€™idÃ©e de cette mÃ©trique est de se rapprocher de lâ€™expÃ©rience de lâ€™utilisateur envers la rÃ©activitÃ© dâ€™une application
web. Cette mÃ©trique observe le temps entre une interaction utilisateur et une rÃ©ponse visuelle de notre interface.

![Preload with surgical precision](/images/posts/2024-10-29-we-love-speed-2024/team_picture.jpeg)

## HTMX

Lors de ce talk, il nous a Ã©tÃ© prÃ©sentÃ© un outil trÃ¨s intÃ©ressant pour amÃ©liorer lâ€™expÃ©rience utilisateur dâ€™une
application web sans effectuer de grosses modifications.
Il s'agit de HTMX, c'est une bibliothÃ¨que Javascript qui permet dâ€™amÃ©liorer lâ€™expÃ©rience utilisateur en ajoutant des
fonctionnalitÃ©s de type SPA (Single Page Application) Ã  une application web classique et de faÃ§on non intrusive.
Par exemple, on peut charger un CDN de maniÃ¨re asynchrone, ou encore charger des images en avance.
Câ€™est-a-dire que si HTMX venait Ã  ne pas dÃ©marrer, votre application web se comporterait de la mÃªme maniÃ¨re, mais sans
les amÃ©liorations de temps dâ€™interaction.

HTMX surcharge la maniÃ¨re dont vos liens et images vont Ãªtre chargÃ©s par le navigateur.
Ainsi, lors de la prochaine interaction avec le navigateur, ce dernier sera dÃ©jÃ  prÃªt Ã  servir les ressources.
Le principe de HTMX consiste Ã  ajouter des balises HTML spÃ©cifiques dans le DOM qu'il va lire et en dÃ©duire les
comportements Ã  son chargement.
Cette manipulation est appelÃ© le "DOM morphing". GrÃ¢ce Ã  ce processus le temps de chargement est rÃ©duite et on Ã©vite
l'effet "blink" (page blanche lors du chargement de la page).
Il est Ã  noter que ces comportements ne sont quâ€™un embellissement proposÃ© par HTMX, il est tout Ã  fait possible
dâ€™ajouter par exemple lâ€™attribut `preload` sur une balise `a` pour demander le chargement en avance du lien par le
navigateur.

> <div style="display: flex">
> <img src="https://ca.slack-edge.com/T108ZKPMF-U01FQRQ8FT7-dfb12b21fb0d-192" alt="Julie" style="padding: 0;border-radius: 50%; height: 70px; margin: 10px">
> Comme nous utilisons React pour notre application, l'utilisation de HTMX n'est pas vraiment utile.
> Il est dÃ©jÃ  possible avec React de prÃ©charger les ressources en avance. Mais Ã§a reste un outil intÃ©ressant...
> </div>

> <div style="display: flex">
> ...effectivement, HTMX semble Ãªtre intÃ©ressant, mais on se retrouve Ã  ajouter
> beaucoup d'attributs dans le HTML. Ã‡a peut le rendre le markup moins lisible. Et en plus, Ã§a donne l'impression de recoder les comportements du navigateur.
> <img src="/images/avatar/j_poissonnet.jpg" alt="Jules" style="padding: 0;border-radius: 50%; height: 70px; margin: 10px">
> </div>

## INP vs JS

Le deuxiÃ¨me talk a une place particuliÃ¨re dans notre cÅ“ur â¤ï¸ puisquâ€™il a Ã©tÃ© donnÃ© par notre cher Jean-Pierre Vincent,
qui a auditÃ© les performances du web de Bedrock, il y a deux ans.
Lors de ce talk, Jean-Pierre nous a donnÃ© la feuille de route pour Ã©viter au mieux la dÃ©ferlante de Javascript que vos
utilisateurs reÃ§oivent au chargement de votre site.

![JS Tsunami storming your users](/images/posts/2024-10-29-we-love-speed-2024/js_tsunami.jpeg)

L'INP (Interaction to Next Paint) est une mÃ©trique qui mesure le temps entre une interaction utilisateur et le prochain.
Lâ€™idÃ©e gÃ©nÃ©rale, c'est de pouvoir mesurer lâ€™incapacitÃ© du navigateur Ã  rÃ©agir. AprÃ¨s avoir rÃ©cupÃ©rÃ© des mesures, il est
bon de
se rappeler quâ€™il y a un biais de selection pour les donnÃ©es de Crux. En effet, il nâ€™est calculÃ© que sur les appareils
Google (câ€™est le principe). Une fois quâ€™on a rÃ©coltÃ© des mÃ©triques de performance de nos utilisateurs, si on veut
travailler sur notre site web et avoir une bonne idÃ©e du ressenti de nos utilisateurs, lâ€™idÃ©al est de tester avec un
vÃ©ritable Samsung S8 par exemple.
Lâ€™INP est une mÃ©trique qui peut Ãªtre influencÃ©e par des interactions qui ne sont pas prÃ©vues par les devs. Câ€™est
pourquoi il est important de se baser sur des donnÃ©es utilisateurs, car on est trÃ¨s souvent Ã©tonnÃ© de voir que quand les
temps de chargement sont un poil trop long Ã  leur goÃ»t, ils se mettent Ã  cliquer partout ğŸ¤·

![INP est bousculÃ© par la charge de js!](/images/posts/2024-10-29-we-love-speed-2024/inp_charge.jpeg)
ï¿¼
Parmi les bonnes pratiques quâ€™on peut appliquer dÃ¨s maintenant, et qui je dois le dire mâ€™a paru un peu contre-intuitif :
Faire passer Babel sur les node_modules.
En fait, du point de vue dâ€™un dÃ©veloppeur, on peut se dire que cela va augmenter les temps de build drastiquement, et on
aurait sÃ»rement raison. Mais en fait, il faut voir le bÃ©nÃ©fice quâ€™il y a derriÃ¨re. Si on personnalise les rÃ¨gles Babel
pour quâ€™elles correspondent aux navigateurs de nos utilisateurs, on sâ€™Ã©vite des transformations inutiles qui
augmenteraient le poids de nos fichiers Javascript.

Une nouvelle fonctionnalitÃ© de React appelÃ©e RSC (React Server Components) permet combiner le rendu cÃ´tÃ© serveur avec
l'interactivitÃ© cÃ´tÃ© client.
Les RSC aident Ã  rÃ©duire la taille du JavaScript dans le navigateur ce qui permet de rÃ©duire le temps d'interaction et
de ce fait amÃ©liore grandement l'expÃ©rience utilisateur.
Vous lâ€™aurez compris, câ€™est lâ€™ennemi nÂ°1 de Jean-Pierre (et de vos navigateurs) !
Le principe est de rendre les composants cÃ´tÃ© serveur et de faire en sorte que ces derniers ne rendent que du HTML, qui
ne sera pas hydratÃ© cÃ´tÃ© client.
Lâ€™Ã©tape de rÃ©hydratation est une Ã©tape importante et trop souvent sous-estimÃ©e. Il sâ€™agit dâ€™une nouveautÃ© de React qui
est prometteuse et qui est dÃ©jÃ  prÃ©sente dans Next.js.

Pour nous montrer un exemple concret dâ€™abus de JavaScript : il a montrÃ© du code Bedrock ğŸ˜….
Il sâ€™agit dâ€™un FlameGraph du rendu de notre `<Footer />` cÃ´tÃ© app web. Il y a une quantitÃ© consÃ©quente de JS car nous
faisions ce quâ€™on appelle du CSS-in-JS.
Vous lâ€™avez devinÃ©, câ€™est la partie "in-JS" qui pose un problÃ¨me. Cela signifie que pour appliquer du style sur notre
site, câ€™est le Javascript qui sâ€™en charge. Or dans un composant, comme le `<Footer />`, il y a beaucoup dâ€™Ã©lÃ©ments et chacun va
avoir besoin son propre style. Si lâ€™idÃ©e de colocaliser le CSS dans le JS nâ€™est pas nocive en soi, le plus gros problÃ¨me
Ã©tait l'utilisation de [Styled-Components](https://styled-components.com/) qui calcule le style au moment du rendu, le rendant donc plus long.
FYI: Entre temps, nous avons chez Bedrock entamÃ© une migration pour quitter Styled-Components au profit de [Linaria](https://linaria.dev/) pour le projet web et [Vanilla Extract](https://vanilla-extract.style/) pour le projet smart TV.

![Flamegraph du Footer de Bedrock](/images/posts/2024-10-29-we-love-speed-2024/flamgraph.jpeg)
ï¿¼
Autre information qui nous concerne chez Bedrock, au moment dâ€™Ã©crire ces lignes, nous sommes en train de mettre en
production la migration de React 17 vers React 18 sur le projet web.
Dâ€™aprÃ¨s les retours dâ€™expÃ©rience de Jean-Pierre, cette version de React aura un impact positif sur lâ€™INP car il permet de faire moins de `render`.

Enfin, Jean-Pierre nous laisse avec un ultime conseil pour que nos applications web soient pÃ©rennes : â€œMonitores (au
moins une fois dans ta vie) lâ€™origine des INP avec un vrai utilisateur.â€

> <div style="display: flex">
> <img src="https://ca.slack-edge.com/T108ZKPMF-U01FQRQ8FT7-dfb12b21fb0d-192" alt="Julie" style="padding: 0;border-radius: 50%; height: 70px; margin: 10px">
> J'ai bien aimÃ© ce talk ! J'ai trouvÃ© que sa prÃ©sentation Ã©tait trÃ¨s accessible, il a su vulgariser des concepts et rendre un sujet chiant (la performance) intÃ©ressant ğŸ‘
> </div>

## Performance avec Chrome DevTools

Avoir un Å“il sur ses performances, câ€™est essentiel pour pouvoir avancer dans la bonne direction et sâ€™assurer quâ€™on
fournit Ã  nos utilisateurs une expÃ©rience optimale. Fort heureusement pour nous les devs, on est bien lotis avec de trÃ¨s
bons outils. Il suffit dâ€™ouvrir les Chrome DevTools pour sâ€™en rendre compte. Il nous a Ã©tÃ© prÃ©sentÃ© lors de ce talk
comment bien utiliser les DevTools pour mesurer les performances de nos applications web et se mettre Ã  la place de
nos utilisateurs. Par exemple, on peut brider son rÃ©seau et son CPU pour simuler une connexion 3G et un CPU lent. Dans
cette prÃ©sentation, on nous a quand mÃªme rappelÃ© que les DevTools ne sont pas une solution miracle, il est important de
tester sur de vrais devices pour le ressenti.

Pour ce qui est de l'interprÃ©tation des donnÃ©es, une myriade d'outils sont Ã  notre disposition pour nous aider Ã 
comprendre ce que nous voyons. Par exemple, on peut ajouter des annotations dans le flamegraph comme des labels, des
diagrammes ou encore des plages de temps. On peut aussi utiliser des custom tracks pour suivre des Ã©vÃ©nements
spÃ©cifiques. Au sein de notre application, on peut utiliser lâ€™API User Timing pour ajouter des points de repÃ¨re dans
notre code et ainsi mieux comprendre ce qui se passe au dÃ©clenchement d'Ã©vÃ©nements spÃ©cifiques.

## Tester la performance avec Lighthouse CI

On a aussi eu un talk sur la mise en place de [Lighthouse CI](https://github.com/GoogleChrome/lighthouse-ci). Avec cet outil de Google, nous pouvons dÃ©sormais mesurer la performance de notre application directement dans notre CI, ce qui peut Ãªtre pratique pour garder un oeil sur les Ã©ventuelles rÃ©gressions.
L'outil en local est trÃ¨s bien, mais il est encore mieux de l'intÃ©grer dans une CI pour automatiser le processus. Cela permet de dÃ©tecter les problÃ¨mes de
performance avant qu'ils ne soient dÃ©ployÃ©s en production. Il est possible de gÃ©nÃ©rer des warnings, voire des erreurs,
en cas de non-respect des standards de performance que nous avons dÃ©finis. L'idÃ©e derriÃ¨re la
mise en place de Lighthouse CI est de s'assurer que la performance de notre application web est toujours au
top et ne se dÃ©grade pas dans le temps. Il est en effet plus facile de corriger une rÃ©gression lorsqu'on peut savoir exactement quelle Pull Request ou commit l'a introduite.
![Key takeaways from the talk](/images/posts/2024-10-29-we-love-speed-2024/Key%20Takeaways.jpeg)

> <div style="display: flex">
> <img src="https://ca.slack-edge.com/T108ZKPMF-U01FQRQ8FT7-dfb12b21fb0d-192" alt="Julie" style="padding: 0;border-radius: 50%; height: 70px; margin: 10px">
> Y'a moyen qu'on l'ajoute au projet smart TV, mais plus pour gÃ©nÃ©rer un rapport de performance quotidien plutÃ´t que de le faire pour chaque push ou merge. 
> </div>

## How browsers really load pages

Dans ce qui est probablement le talk le plus technique de la journÃ©e, on nous a expliquÃ© comment les navigateurs
chargent les diffÃ©rentes ressources nÃ©cessaires Ã  l'affichage d'une page web. Plus spÃ©cifiquement, on nous a expliquÃ©
comment les navigateurs interprÃ¨tent le HTML pour dÃ©terminer quelles ressources charger en prioritÃ©. 

Le talk Ã©tait trÃ¨s intÃ©ressant, mais la conclusion est un peu frustrante : il est pour le moment impossible de prÃ©voir
l'ordre de chargement des ressources par le navigateur Ã  partir du mÃªme HTML. En effet, les navigateurs ont des
comportements diffÃ©rents entre eux et mÃªme par version ğŸ¤¯. Chrome a, par exemple, un comportement trÃ¨s diffÃ©rent cette annÃ©e
par rapport Ã  deux ans en arriÃ¨re.

MÃªme si on est tentÃ© de vouloir contrÃ´ler le chargement des ressources, il est important de se rappeler que le navigateur
est trÃ¨s bien optimisÃ© pour charger les ressources de maniÃ¨re efficace. Il est donc prÃ©fÃ©rable de laisser le navigateur
faire son travail plutÃ´t que de vouloir le contrÃ´ler. L'attribut `preload` est un bon exemple de ce que l'on peut faire
pour aider le navigateur Ã  charger les ressources de maniÃ¨re plus efficace. Il faut cependant l'utiliser avec parcimonie
et de maniÃ¨re chirurgicale pour ne pas interfÃ©rer avec le travail du navigateur.
ï¿¼
![Preload with surgical precision](/images/posts/2024-10-29-we-love-speed-2024/preload_surgical.jpeg)
ï¿¼
## Mais que fait la police ?!

Pour finir, on a eu un talk sur les polices de caractÃ¨res. Elles sont essentielles pour l'identitÃ© visuelle de nos
applications web, mais elles peuvent aussi Ãªtre une source de problÃ¨mes de performance. En effet, les polices de
caractÃ¨res peuvent Ãªtre trÃ¨s lourdes et ralentir le chargement de nos pages. Il est donc important de bien les choisir
et de les optimiser pour garantir une bonne performance. Il existe plusieurs techniques pour optimiser les polices, 
notamment en rÃ©alisant un subset de la police pour ne tÃ©lÃ©charger que les glyphes dont on a besoin. (En franÃ§ais, on a
besoin que de 165 glyphes comparÃ© Ã  528 pour le latin).
Il existe des outils pour nous aider Ã  rÃ©aliser ces subsets comme: [Font Subsetter](https://everythingfonts.com/subsetter), [fontTools](https://fonttools.readthedocs.io/) ou
[Glyphanger](https://www.zachleat.com/web/glyphhanger/) .
> <div style="display: flex">
> Attention Ã  ne pas abuser des subsets, car cela peut entraÃ®ner des problÃ¨mes de lisibilitÃ© du texte. Le fameux tğŸ ‰fu .
> <img src="/images/avatar/j_poissonnet.jpg" alt="Jules" style="padding: 0;border-radius: 50%; height: 70px; margin: 10px">
> </div>

![Say no to tofu](/images/posts/2024-10-29-we-love-speed-2024/tofu.jpeg)

Il est aussi possible de minimiser le nombre de fichiers en utilisant des polices variables. Un bon exemple, c'est la police Roboto Flex, qui est customisable et permet ainsi de pouvoir rÃ©duire le nombre de fichiers nÃ©cessaires Ã  charger. Il est lÃ  aussi,
possible de sÃ©lectionner les variations que l'on souhaite pour rÃ©duire encore plus le poids de la police.


# Conclusion

Cette annÃ©e, l'accent a Ã©tÃ© mis sur l'INP et la maniÃ¨re de l'amÃ©liorer. Il est important de garder en tÃªte que l'INP est
une mÃ©trique qui mesure l'expÃ©rience utilisateur, il est donc essentiel de la garder Ã  l'Å“il. Il est bon de rappeler
que la performance est plus une habitude Ã  prendre qu'un constat Ã  rÃ©aliser. Une application performante c'est une expÃ©rience utilisateur amÃ©liorÃ©e et des utilisateurs satisfaits !

Notre Ã©quipe est ressortie de cette confÃ©rence ravie et avec de nouvelles idÃ©es Ã  mettre en place pour notre plateforme. 
La We love speed â¤ï¸ est une confÃ©rence Ã  ne pas manquer pour tous les passionnÃ©s de performance web, on vous recommande
chaudement d'y assister si vous en avez l'occasion !
